<title>smoke</title>

<style>
html,
body {
  height: 100%;
}
body {
  overflow: hidden;
  margin: 0;
}
canvas {
  width: 100%;
  height: 100%;
}
</style>

<body>
<canvas></canvas>

<script>
const plainVertexShader = `
attribute vec3 position;
varying vec4 vPosition;

void main() {
  gl_Position = vPosition = vec4(position, 1.);
}
`

class WebGl {
  constructor (option) {
    const {
      canvas,
      vertexShader = plainVertexShader,
      fragmentShader,
      uniforms,
      clearedColor,
      mode = 'TRIANGLE_STRIP',
      tick = () => {},
      onResize,
      isAutoStart = true
    } = option
    const isPlain = !option.vertexShader

    this.attributes = {}
    this.uniforms = {}
    this.textureIndexes = {}
    this.attributeCount = 0
    this.textureIndex = -1

    this.canvas = canvas
    this.mode = mode
    this.tick = tick
    this.onResize = onResize

    this.initWebGL()
    this.createProgram(vertexShader, fragmentShader)
    if (isPlain) this.createPlainAttribute()
    if (uniforms) this.createUniform(uniforms)
    this.clearColor(clearedColor)
    this.initSize()
    if (isAutoStart) this.start()
  }

  initWebGL () {
    this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl')
  }

  createShader (type, content) {
    const shader = this.gl.createShader(this.gl[type])
    this.gl.shaderSource(shader, content)
    this.gl.compileShader(shader)

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error(this.gl.getShaderInfoLog(shader))
      return
    }

    return shader
  }

  createProgram (vertexShader, fragmentShader) {
    this.program = this.gl.createProgram()
    this.gl.attachShader(this.program, this.createShader('VERTEX_SHADER', vertexShader))
    this.gl.attachShader(this.program, this.createShader('FRAGMENT_SHADER', fragmentShader))
    this.gl.linkProgram(this.program)

    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error(this.gl.getProgramInfoLog(this.program))
      return
    }

    this.gl.useProgram(this.program)

    if (!this.program) throw new Error('Failed to create this.program.')
  }

  createAttribute (data) {
    Object.keys(data).forEach(key => {
      const { stride, value } = data[key]
      this.attributes[key] = {
        location: this.gl.getAttribLocation(this.program, key),
        stride,
        vbo: this.createVbo(value)
      }

      this.attributeCount += value.length / stride
    })
  }

  createPlainAttribute () {
    const position = [
      -1, 1, 0,
      -1, -1, 0,
      1, 1, 0,
      1, -1, 0
    ]

    this.createAttribute({
      position: {
        stride: 3,
        value: position
      }
    })

    this.setAttribute('position')
  }

  createVbo (data) {
    const vbo = this.gl.createBuffer()
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo)
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW)
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null)
    return vbo
  }

  setAttribute (name) {
    const { vbo, location, stride } = this.attributes[name]

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo)
    this.gl.enableVertexAttribArray(location)
    this.gl.vertexAttribPointer(location, stride, this.gl.FLOAT, false, 0, 0)
  }

  addUniform (name, value, type) {
    let uniformType = type
    let uniformValue = value

    if (type === 'image') {
      uniformType = '1i'
      uniformValue = this.createTexture(value, name)
    }

    this.uniforms[name] = {
      location: this.gl.getUniformLocation(this.program, name),
      type: `uniform${uniformType}`
    }

    if (typeof uniformValue !== 'undefined') this.setUniform(name, uniformValue)
  }

  createUniform (data) {
    const mergedData = Object.assign({
      resolution: {
        type: '2fv'
      }
    }, data)

    Object.keys(mergedData).forEach(name => {
      const { type, value } = mergedData[name]
      this.addUniform(name, value, type)
    })
  }

  setUniform (name, value) {
    const uniform = this.uniforms[name]
    if (!uniform) return

    this.gl[uniform.type](uniform.location, value)
  }

  createTexture (img, name) {
    const textureIndex = ++this.textureIndex
    const texture = this.gl.createTexture()
    this.textureIndexes[name] = textureIndex

    this.gl.activeTexture(this.gl[`TEXTURE${textureIndex}`])
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture)
    // this.gl.generateMipmap(this.gl.TEXTURE_2D)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img)

    return textureIndex
  }

  getTextureIndex (name) {
    return this.textureIndexes[name]
  }

  updateTexture (name, img) {
    this.activeTexture(this.getTextureIndex(name))
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img)
  }

  clearColor (clearedColor = [0, 0, 0, 1]) {
    this.gl.clearColor(...clearedColor)
  }

  setSize () {
    const width = this.canvas.clientWidth
    const height = this.canvas.clientHeight

    this.canvas.width = width
    this.canvas.height = height

    this.gl.viewport(0, 0, width, height)
    this.setUniform('resolution', [width, height])

    if (this.onResize) this.onResize()
  }

  initSize () {
    this.setSize()
    window.addEventListener('resize', () => { this.setSize() })
  }

  start () {
    requestAnimationFrame(timestamp => {
      this.initialTimestamp = timestamp
    })

    const render = timestamp => {
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)

      this.setUniform('time', (timestamp - this.initialTimestamp) / 1000)

      this.tick(timestamp)

      this.gl.drawArrays(this.gl[this.mode], 0, this.attributeCount)

      this.requestID = requestAnimationFrame(render)
    }
    this.requestID = requestAnimationFrame(render)
  }

  stop () {
    if (!this.requestID) return

    cancelAnimationFrame(this.requestID)
    this.requestID = null
  }
}

function loadImage (src, isCrossOrigin) {
  const img = new Image()

  const promise = new Promise(resolve => {
    img.addEventListener('load', () => {
      resolve(img)
    })
  })

  if (isCrossOrigin) img.crossOrigin = 'anonymous'
  img.src = src

  return promise
}

const fragmentShader = `
precision highp float;

uniform vec2 resolution;
uniform sampler2D image;
uniform vec2 imageResolution;
uniform float time;

varying vec4 vPosition;

//
// Description : Array and textureless GLSL 2D/3D/4D simplex
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
  {
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i);
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

vec2 getUv(vec4 position) {
  vec2 uv = (position.xy + 1.) * 0.5;
  uv.y = 1. - uv.y;
  return uv;
}

vec2 adjustRatio(vec2 coord, vec2 inputResolution, vec2 outputResolution) {
  vec2 ratio = vec2(
    min((outputResolution.x / outputResolution.y) / (inputResolution.x / inputResolution.y), 1.0),
    min((outputResolution.y / outputResolution.x) / (inputResolution.y / inputResolution.x), 1.0)
  );
  return coord * ratio + (1. - ratio) * 0.5;
}

void main() {
  vec2 uv = getUv(vPosition);

  float existence = snoise(vec3(uv, 10.));
  existence = mix(0.3, 1., existence);
  existence *= time * 0.5;
  // existence = pow(existence, 2.);
  // existence = step(1., existence);

  uv = adjustRatio(uv, imageResolution, resolution);
  vec3 color = texture2D(image, uv).rgb;

  gl_FragColor = vec4(color, mix(1., 0., step(1., existence)));
  // gl_FragColor = vec4(color, 1.);
  // gl_FragColor = vec4(vec3(existence), 1.);
}
`

loadImage('images/room.jpg').then(img => {
  const webGl = new WebGl({
    canvas: document.querySelector('canvas'),
    fragmentShader,
    uniforms: {
      time: {
        type: '1f',
        value: 0
      },
      imageResolution: {
        type: '2fv',
        value: [img.width, img.height]
      },
      image: {
        type: 'image',
        value: img
      }
    }
  })
})
</script>
</body>
